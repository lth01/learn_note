## JOIN
JOIN은 데이터베이스 내 관계성이 있는 테이블에서 가져온 레코드를 이어 붙여주는 역할을 수행한다.

JOIN은 INNER, FULL OUTER, LEFT, RIGHT등 다양한 JOIN이 존재한다.

### INNER JOIN
가장 기본이 되는 JOIN으로 ON절에 기술된 조건이 **일치하는 결과**만 **붙여서** 결과를 반환한다.

```postgresql
SELECT * FROM
TBALEA AS A
INNER JOIN TABLEB AS B
ON A.attribute = B.attribute
```

### LEFT/RIGHT/FULL OUTER JOIN
처음 학습하는 입장으로써 여기부터 헷갈리기 시작했다.

INNER JOIN에서 ON절의 조건이 일치하지 않는 레코드는 모두 버려진다.

하지만 LEFT/RIGHT/FULL OUTER 조인에서는 ON절에 조건에 부합하지 않는 테이블 레코드가 있더라도, 이를 표현해준다.

예시를 보자.

> students 테이블

| name | age | address |
| ---- | --- | ------- |
| 정약용  | 29  | 경기도     |
| 김정호  | 30  | 전라북도    |
| 박지원  | 31  | 전라북도    |
| 김홍도  | 32  | 경기도     |
| 신윤복  | 33  | 서울특별시   |
| 김광균  | 34  | 서울특별시   |
| 한용운  | 35  | 경상남도    |
| 박두진  | 36  | 경기도     |

> classes 테이블

| name | class_name |
| ---- | ---------- |
| 이황   | 데이터베이스     |
| 이황   | 알고리즘       |
| 정약용  | 데이터베이스     |
| 김정호  | 자료구조       |
| 박지원  | 데이터베이스     |
| 김홍도  | 알고리즘       |
| 신윤복  | 자료구조       |
| 신윤복  | 알고리즘       |
| 김광균  | 데이터베이스     |
| 김광균  | 자료구조       |
| 김광균  | 알고리즘       |

위의 예시 테이블처럼 두 테이블을 합친다 생각해보자.
코드는 아래와 같다.

```postgresql
SELECT * FROM
STUDENTS S [LEFT | RIGHT | FULL] OUTER JOIN CLASSES C
ON S."NAME" = C."NAME";
```

students.name = classes.name이 조건일 때, 

Students 테이블은 한용운, 박두진 이름을 갖는 두 레코드가
Classes 테이블은 이황 이름을 갖는 두 레코드가 위 조건을 만족하지 않는다.

아래에서 어떤식으로 각 OUTER 조인별로 어떻게 표현되는지 확인해보자.
#### LEFT OUTER JOIN
| name | age | address | name-2 | class_name |
| ---- | --- | ------- | ------ | ---------- |
| 정약용  | 29  | 경기도     | 정약용    | 데이터베이스     |
| 김정호  | 30  | 전라북도    | 김정호    | 자료구조       |
| 박지원  | 31  | 전라북도    | 박지원    | 데이터베이스     |
| 김홍도  | 32  | 경기도     | 김홍도    | 알고리즘       |
| 신윤복  | 33  | 서울특별시   | 신윤복    | 알고리즘       |
| 신윤복  | 33  | 서울특별시   | 신윤복    | 자료구조       |
| 김광균  | 34  | 서울특별시   | 김광균    | 알고리즘       |
| 김광균  | 34  | 서울특별시   | 김광균    | 자료구조       |
| 김광균  | 34  | 서울특별시   | 김광균    | 데이터베이스     |
| 한용운  | 35  | 경상남도    | NULL   | NULL       |
| 박두진  | 36  | 경기도     | NULL   | NULL       |
students 테이블에서 이름이 일치할 경우 INNER JOIN과 같이 붙여 출력하되, 이름이 일치하는 레코드가 없더라도 students테이블에 있는 값은 모두 출력된다.
#### RIGHT OUTER JOIN
| name | age  | address | name-2 | class_name |
| ---- | ---- | ------- | ------ | ---------- |
| NULL | NULL | NULL    | 이황     | 알고리즘       |
| NULL | NULL | NULL    | 이황     | 데이터베이스     |
| 정약용  | 29   | 경기도     | 정약용    | 데이터베이스     |
| 김정호  | 30   | 전라북도    | 김정호    | 자료구조       |
| 박지원  | 31   | 전라북도    | 박지원    | 데이터베이스     |
| 김홍도  | 32   | 경기도     | 김홍도    | 알고리즘       |
| 신윤복  | 33   | 서울특별시   | 신윤복    | 알고리즘       |
| 신윤복  | 33   | 서울특별시   | 신윤복    | 자료구조       |
| 김광균  | 34   | 서울특별시   | 김광균    | 알고리즘       |
| 김광균  | 34   | 서울특별시   | 김광균    | 자료구조       |
| 김광균  | 34   | 서울특별시   | 김광균    | 데이터베이스     |

RIGHT OUTER JOIN은 이름이 일치하지 않는 한윤복, 박두진 레코드는 버리고, 이름이 일치하지 않는 RIGHT TABLE(classes)의 이황 레코드는 모두 살려놓은 것을 볼 수 있다.

#### FULL OUTER JOIN
| name | age  | address | name-2 | class_name |
| ---- | ---- | ------- | ------ | ---------- |
| NULL | NULL | NULL    | 이황     | 알고리즘       |
| NULL | NULL | NULL    | 이황     | 데이터베이스     |
| 정약용  | 29   | 경기도     | 정약용    | 데이터베이스     |
| 김정호  | 30   | 전라북도    | 김정호    | 자료구조       |
| 박지원  | 31   | 전라북도    | 박지원    | 데이터베이스     |
| 김홍도  | 32   | 경기도     | 김홍도    | 알고리즘       |
| 신윤복  | 33   | 서울특별시   | 신윤복    | 알고리즘       |
| 신윤복  | 33   | 서울특별시   | 신윤복    | 자료구조       |
| 김광균  | 34   | 서울특별시   | 김광균    | 알고리즘       |
| 김광균  | 34   | 서울특별시   | 김광균    | 자료구조       |
| 김광균  | 34   | 서울특별시   | 김광균    | 데이터베이스     |
| 한용운  | 35   | 경상남도    | NULL   | NULL       |
| 박두진  | 36   | 경기도     | NULL   | NULL       |
FULL OUTER JOIN은 조건에 일치하지 않는 레코드더라도 양측 테이블에서 값이 없는 열을 NULL로 채운뒤 연결해준다.

## UNION
JOIN은 연관성이 있는 두 테이블을 연결하는 역할을 수행한다.

하지만, UNION은 단순히 두 SQL을 실행한 뷰를 합치는 역할을 수행한다.

UNION으로 두 뷰를 합치기 위해서는 몇 가지 조건을 만족해야한다.
1. SQL 1과 SQL 2의 열 개수가 같아야한다.
2. SQL 1과 SQL 2의 열 이름이 같아야한다.
3. SQL 1과 SQL2의 각 열 데이터 타입이 동일해야한다.

즉 합치고자 하는 두 뷰는 동일한 형태와 타입을 가져야한다는 것이다.

### UNION

```postgresql
[SQL 1]
UNION
[SQL 2]
```

UNION은 레코드의 모든 열값이 동일한 경우 중복된 레코드를 제거한다.

만약 중복된 레코드를 허용하고자 할 경우

**UNION ALL**을 사용해야한다.

### UNION ALL
```postgresql
[SQL1]
UNION ALL
[SQL 2]
```