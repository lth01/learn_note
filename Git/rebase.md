---
Date: 2024-01-03
reference: https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-Rebase-%ED%95%98%EA%B8%B0
Subject: Git Rebase 원리와 사용방법
---
깃에서 소스를 합치는 방법 중 가장 먼저 배우는 것은 merge이다. 

현재 작업 중인 브랜치와 병합하려는 브랜치가 자식 - 부모 관계일 경우 수행되는 **fast-forward**

현재 작업 중인 브랜치와 병합하려는 브랜치가 공통 브랜치의 자식이지만 다른 분기를 갖고있는 경우 수행되는 3-way-merge가 있다.

위의 두가지는 실제로도 많이 사용했고, 관련 걔념을 공부도 하다보니 익숙한 감이 있다. 하지만, 다른 방법이 하나 더 있었으니.. 

그이름하야 rebase이다.
# Rebase가 무엇인가요?
rebase의 정의는 아래와 같다.

*rebase는 커밋 시퀀스를 새 기준 커밋으로 이동하거나 결합하는 프로세스입니다. --아틀라시안--*

커밋 시퀀스는 무엇이고, 이걸 어디로 어떻게 옮긴다는 것일까?
- 언제나 정답은 딥하게 팔때 나온다... Git SCM 에서 직접 어떤식으로 동작하는지 확인해보자.

![Pasted image 20240103171521.png](../리소스/rebase_1.png)

C3, C4 커밋이 있다. rebase를 수행하여 Master 브랜치에 C4를 합치고 싶다 가정해보자.

아래의 명령어를 입력해보자
```shell
git checkout experiment
git rebase master
```

아래의 명령어를 수행하면 git rebase는 C4의 변경사항을 저장해놓은뒤 C4의 포인터를 C3의 뒤에 임시로 저장해놓는다.

그다음 C3의 적용 사항을 C4에 적용하여 최종적으로는 C4'의 커밋을 만들어놓는다.

완료된 상황을 보자. 어디서 많이 본 그림이다. 머리속에 딱 떠오르는 상황이 있다면 잘했다고 스스로 어깨를 토닥여주자.

**Fast-Forward** ! 그렇다. experiment 브랜치의 분기되었던 기록은 사라지고, 이제 experiment 브랜치가 master브랜치의 자식 브랜치가 되었다.

이제 아래의 명령어를 통해 우리의 원래 목표였던 master브랜치가 C4의 변경내용을 적용하도록 만들 수 있다.

```shell
git checkout master
git merge experiment
```

결과는 사실 3-way-merge와 동일하다. 그렇다면 무엇이 다를까?

결과적으로는 서로 분기되어있던 두 브랜치를 합친다는 것은 동일하지만, 과정은 꽤나 다르다.

### 3-way-merge의 경우
3-way-merge는 두 브랜치의 최종 커밋과 두 브랜치의 공통 조상 커밋을 비교하여 소스코드를 합친다.

### rebase의 경우
rebase는 두 브랜치 중 한 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 소스코드를 합친다.
- 이 차이때문에 rebase시 작업 브랜치의 커밋 이력은 사라진다.


# 그래서 뭐 쓰냐?
두 방법은 서로 장단점이 너무나 확실하다.

|  | 장점 | 단점 |
| ---- | ---- | ---- |
| merge | 병합 시킨 브랜치의 개발 이력이 모두 남아있다. | 불필요한 이력도 계속해서 남아있다. |
| rebase | rebase 시킨 브랜치의 개발 이력이 깔끔히 없어진다. | rebase시킨 브랜치에서 추가 버그가 발생했을때, 개발자가 개발 이력을 파악하기 어렵다. |

나라면 유지보수가 필요없거나, 나말고 유지보수가 불가능하도록 하고싶거나(장난이다. 윤리적으로 이러면 안된다.), 간단한 프로젝트같은 경우 핵심적인 기능들만 하나씩 파악하도록 rebase를 사용하고 유지보수가 지속적으로 필요하고, 분업화가 많이되어있는 프로젝트인 경우 merge를 사용할 것같다.

