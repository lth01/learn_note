---
Date: 2024-03-12
reference: 스프림 핵심 원리 - 기본편
---
의존관계 주입 방법은 4가지가 있음

1. 생성자
2. setter
3. @AutoWired
4. 일반메소드


## 생성자를 통한 의존관계 주입
생성자를 통한 의존관계 주입시 불변성이 보장됨

빈 클래스 내부에 생성자가 단 한개만 존재하면, 스프링에서 자동으로 의존관계 주입
그 이외에는 `@AutoWired` 어노테이션을 사용해야한다.

생성자 주입은 빈을 등록할 때, 같이 의존관계 주입이 일어난다.
- 자바 코드상 생성자가 호출될 때 의존관계 주입이 필요하므로

## Setter 주입
수정자 메서드를 통해 의존관계를 주입하는 방법

특징
- "**선택, 변경**" 가능성이 있는 의존관계에서 사용
- 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법

> 자바 빈 프로퍼티
> 자바에서 필드의 값을 직접 변경하지 않고 setXXX, getXXX 메서드를 통해 값을 읽거나 수정하는 규칙

## 필드 주입
그냥 필드에 `@AutoWired` 어노테이션으로 의존관계를 주입하는 행위
- 테스트 시 BootString Test가 아닌 자바 깡으로는 테스트가 불가능
	- 생성자, Setter는 개발자가 임의로 객체 삽입 가능
- 어노테이션의 동작자체가 Spring 의존적임

## 일반 메서드 주입
아무 메서드에 `@AutoWired`메서드 사용하여 의존관계를 주입
-> 보통... 많이 안씀


## 그래서 뭐쓰는데?
과거에는 수정자, 필드 주입을 많이 사용했으나 요즘 DI 프레임워크는 대부분 생성자 주입을 권장한다.

### 왜?
**불변성**

1. 대부분의 의존관계는 애플리케이션이 종료되는 시점까지 의존관계를 변경할 일이 없다. 오히려 많은 의존관계는 어플리케이션 종료 전까지 불변성을 보장해야한다.
2. 수정자 주입을 사용하면, setXXX메서드를 public으로 작성해야한다.

**누락 방지**
1. Setter주입시 의존관계를 바로 확인하기 어렵다.
2. 스프링을 사용하지 않은 자바에서 테스트시 개발자가 임의로 의존관계를 주입하기 어렵다.

즉 런타임에서 발생할 수 있는 오류를 -> 컴파일시간에 확인할 수 있도록 수정한다.

## `@Autowired`를 이용한 필드명 매핑
스프링이 컴포넌트 스캔으로 의존관계를 주입할 때, 기본적으로는 타입 매칭을 통해 의존 관계를 주입한다.

하지만 인터페이스를 구현한 컴포넌트가 두개가 있을 때는 어떻게될까?

![java_spring_duplicateTypeComponent.png](../../리소스/java_spring_duplicateTypeComponent.png)

이렇게 빈의 타입이 매칭되는 두개의 컴포넌트가 있으나, 어떤걸 넣어야할지 모르겠다 오류를 던진다!

그렇다면 이를 해결하기 위해 어떤 방법들이 있을까?

### 인스턴스명을 수정한다.
`@Autowired`가 걸린 인스턴스의 이름을 내가 원하는 빈 컴포넌트 이름으로 변경한다.
-> 타입이 동일할 때, 스프링은 빈 이름 중 더 알맞은 빈을 선택하여 주입한다.

### `@Qualifier` 어노테이션을 사용한다.

Qualifer는 일종의 힌트를 제공한다.
```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDisCountPolicy implements DiscountPolicy{
...
}
```

```java
public class OrderServiceImpl implements OrderService{
	private final DiscountPolicy;
	@Autowired
	public OrderServiceImple(@Qualifier("mainDiscountPolicy") DiscountPolicy discountPolicy){
	...
	}
}
```

이렇게 의존 관계 주입이 필요한 인자 앞에 Qualifer를 명시하여 빈 이름을 찾는데 추가적인 힌트를 제공할 수 있다.

#### 나의 생각
퀄리파이어는 빈의 이름이 아닌 구분자 이름 정보를 사용하여 의존 관계 주입할 빈을 선택한다.

이를 위해서는 실제 Qualifier를 사용하여 매핑할 클래스에 어노테이션 + 빈을 사용해야하는 클래스에 각각 퀄리파이어를 명시해야한다.

1. 일단 시간이 많이 걸린다.
2. 각 클래스를 돌아가며 퀄리파이어를 입력하며 개발자의 휴먼 에러 가능성을 부정하기 힘들다.

따라서, 후에 나오는 Primary어노테이션이 퀄리파이어의 대체제로서 적절하다 생각한다.

### `@Primary` 어노테이션

`@Primary`어노테이션은 동일한 타입의 빈이 여러개일 경우 어노테이션이 붙어있는 빈을 최우선으로 매핑한다.
- 일종의 Default를 설정하는 것.


### 어노테이션간 우선순위
동일한 타입의 빈이 여러개 조회되었을 때, `@Qualifier`, `@Primary` 어노테이션으로 선택의 우선순위를 지정할 수 있었다.

그렇다면 두 어노테이션의 우선순위는 어떻게 지정될까?

1. `@Qualify`
2. `@Primary`

어떻게 생각하면 당연한 이유다.

`@Primary` 어노테이션은 default 빈을 지정한다. 그에 비해 `@Qualifier`는 직접 매칭될 빈이 무엇인지 선택자를 지정한다.

CSS에서 같은 depth이면 클래스가 태그 명보다 우선순위를 갖는것처럼

더 명시적인 `@Qualifier` 어노테이션이 우선순위가 높다.

강의에서 실제 `@Primary`는 기본 DB를 커넥션 빈에 붙이고, `@Qualifier`는 가끔 사용하는 서브 데이터베이스 커넥션 빈에 명시하여 필요할때, 빈을 동적으로 주입하는 방법을 사용한다고한다.


## 빈 의존관계 주입 어떻게 관리하는게 좋을까?
**편리한 자동을 기본으로 사용**

스프링을 사용하며 개발자들이 불편했던 사항들을 편리하게 발전시켜나가는 것이 추세이다. 스프링 부트는 컴포넌트 스캔을 기본적으로 진행하고, 컴포넌트 빈들도 조건이 맞으면 자동으로 등록되도록 설정해놓았다.

결정적으로 어노테이션 수정 이외에는 OCP, DIP를 지킨다 볼 수 있다.

따라서, 특별한 상황이 아닐 경우, 우리는 수동 빈 등록을 사용하는 것이 좋을 것이다.

**특별한 상황**

   애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.
**업무 로직 빈**: 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 레포지토리 등이 모두 업무 로직이다.
**기술 지원 빈**: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용한다. DB연결, 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들을 의미한다.

기술 지원 로직은 업무 로직에 비해서 그 수가 매우 적고, 보통 어플리케이션 전반에 걸쳐 광범위하게 영향을 미친다. 또한 업무 로직은 문제가 발생했을 때 어디가 문제인지 명확하게 잘 들어나지만, 기술지원 로직은 적용이 잘 되는지 확인조차 어려운 경우가 많다.

따라서 이런 기술 지원 로직은 수동 빈 등록을 사용하여 명확하게 하는 것이 좋다.

**어플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수하기 좋다.**
-> 그래서 다른 회사에 모듈로 제공할 때 필요한 설정 값들은 Config파일에 몰아 넣어놓고, 메뉴얼을 제공하는 거구만..


  **비즈니스 로직을 사용하지만, 다형성을 적극적으로 사용하는 경우**
세부 구현체가 빈번하게 변경되어 실행되야하는 경우가 있을것이다(할인 정책) 이런 경우 Bean 타입을 메서드 호출시마다 골라주어야한다. 개발자가 여기서 어떤 빈들이 주입될 수 있는지, 어떤 빈들이 있는지 쉽게 알 수 있을까?

이런 경우, 수동으로 빈을 등록하거나 같은 패키지에 묶어 로직을 돌아가게 하기 위해 필요한 구분 단위임을 명시하는 것이 좋다.


