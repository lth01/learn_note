---
Date: 2024-03-11
reference: 스프림 핵심 원리 - 기본편
---
## AppConfig의 문제점
AppConfig에서 우리는 직접 스프링 빈들을 나열했다.

하지만, 실제 서비스 어플리케이션을 상상해보자. 수백, 수천개의 빈들이 있다면 이를 모두 등록하는게 간단할까?
아마 누락도 많이 발생할 것이고, 실수도 많이 발생할 것이다.

스프링은 이런 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔 기능을 제공한다.

컴포넌트 스캔은 @Component 어노테이션이 붙은 클래스를 자동으로 스프링 컨테이너에 빈형태로 들고한다.

## Component Scan 및 DI 과정
1. 컴포넌트 스캔은 컴포넌트 어노테이션이 붙은 모든 클래스를 스프링 빈으로 등록한다.
	- 이때 스프링 빈의 기본 이름은 클래스명이되, 맨 앞글짜는 소문자이다.
		- "빈 이름 직접 지정" : 빈 이름을 직접 지정하고 싶으면 `@Component("${빈이름}")`

2. `@AutoWired` 의존관계 자동 주입
	컴포넌트 클래스에서 `@AutoWired` 어노테이션을 지정하면, 스프링 컨테이너가 자동으로 스프링 빈을 찾아 주입한다.
	> 의존 관계 주입 위한 전략
	> 	- 빈의 이름과 매개변수 타입이 같은 빈을 찾는다.


### 탐색 위치 및 기본 스캔 대상 지정
Component 스캔은 `@ComponentScan` 어노테이션이 붙어있는 클래스의 패키지를 루트 디렉토리로 두고, 하위의 패키지를 모두 탐색하며 Compnent를 찾고 Bean으로 등록한다.
- 패키지가 엄청 많기도하고, 특정한 패키지만 설정하고 싶을 경우 
  `@ComponentScan()`괄호 안에 `basePackages = "패키지 명" || {"패키지 명1", "패키지 명2"}` 와같이 등록할 수 있다.

**권장하는 방법**
패키지 위치를 지정하지않고, 최상단에 설정 정보 클래스(`@ComponentScan`)을 두는 것이다(전체 탐색)
- 스프링 부트도 기본적으로 패키지 최상단에 `@SpringBootApplication` 클래스 내부에 컴포넌트 스캔이 들어있다.


#### 스캔 기본 대상
컴포넌트 스캔은 `@Component` 이외에도 아래의 대상도 빈 컨테이너에 추가로 등록한다.
- `@Component`: 컴포넌트 스캔에서 사용
- `@Controller` : 스프링 MVC 컨테이너에서 사용
- `@Service`: 스프링 비즈니스 로직에서 사용
- `@Repository`: 스프링 데이터 접근에서 사용
- `@Configuration`: 스프링 설정 정보에서 사용

스캔 대상 어노테이션 목록을 cmd + b로 구현을 찾아보면, `@Component` 어노테이션이 내부적으로 등록이 되어있다!

따라서 스캔 대상 어노테이션을 확장한 어노테이션 역시 컴포넌트 스캔의 대상이 될 것이다.

> ✨ 어노테이션은 확장(상속)이 없다.
>  자바는 기본적으로 어노테이션을 상속할 수 있도록 만들어 두지 않았다.
>  우리가 스프링에서 상속하듯이 어노테이션을 사용하는 것은 스프링이 제공하는 문법적 설탕이다.


### 중복 등록과 충돌이 나면?
클래스에 컴포넌트 어노테이션을 붙일 때, 빈의 이름을 등록하는 방법은 자동, 수동 두가지가 있었다.

만약에 개발자의 실수로, 빈 이름이 겹치면 어떻게 될까?

3가지 경우의 수가 있다.

1. 자동 vs 자동(클래스 명을 동일하게 하는경우.. 거의 없다봐야함)
2. 수동 vs 수동(이 역시 많이 일어나는 일은 아니다.)
3. 수동 vs 자동(이건 많음!)

컴포넌트 스캔을 할 때, 수동으로 등록한 빈이름과 자동 빈 이름이 겹칠 경우

수동으로 등록한 빈을 오버라이드한다! 사실 했었다!

근데, 잘 생각해보자. 메서드만 하더라도 서비스를 개발하다보면 동일한 명의 메서드가 많이 나오는데 과연 빈 이름은 그렇지 않을까?

정말 개발자가 의도적으로 오버라이드한걸까?
- 애매한 버그!

**최근 스프링 부트는 오버라이드에도 에러를 발생시킨다.**
