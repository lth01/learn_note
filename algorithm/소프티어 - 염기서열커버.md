
# 문제
https://softeer.ai/practice/6249


각 문자열에 a, g, t, c, .(와일드 카드)로 된 캐릭터가 들어감

-> 좋은 염기서열 문자열 여러개가 들어왔을때, 좋은 염기서열을 포함하는 염기서열을 **초 염기서열**이라 하는데, 이때 초 염기서열의 갯수가 최소가 되도록 염기서열을 구성해보라는 문제임

## 내가 접근한 방법
좋은 염기서열들을 열 하나하나씩 비교한다.
-> 집합에 넣고, 열별 상이한 염기서열의 갯수를 리스트에 추가한다.
-> 리스트중 가장 큰 값을 반환

### 반례
> 4 5 
> a..tt
> gcc..
> .cg..
> acc..

상이한 염기의 카운트를 각 열마다 확인해보면, 2, 1,2,2,1이다.

하지만 우리가 직접 판단해보면 a..tt와 acc..를 포함하는 경우 gcc..와 .cg..는 포함하지 못한다.
따라서 초염기서열의 최소 필요 갯수는 3이다.

## 어떻게 접근하는가?
문제 풀이 영상을 참고했을때, 접근한 방법은 다음과같다.

좋은 염기서열을 만족하는 것을 비트 스트링으로 나타낸다.

N = 3일 때
좋은 염기서열 1
좋은 염기서열 2
좋은 염기서열 3
을 모두 만족하면 111, 2까지만 만족하면 110, 1만 만족하면 100이런식으로

### 왜 이렇게 접근했지?
모든 가능한 초염기서열을 먼저 만든 뒤, DP 접근 방법을 사용한다.

N이 4일때, 모든 좋은 염기서열을 포함할 수 있는 경우 1111의 비트 스트링으로 표현될 것이다.
1111이 유효한 비트스트링이려면, 
1110, 1101, 1001, 0111이 모두 머지가 가능해야한다.
아래로 내려갈수록 트리형식으로 많아질 것이다.

따라서 가장 작은 비트스트링부터 하나씩 늘려가며, 머지 가능한 경우 머지해야한다.

#### 내가 생각하지 못한 것
머지를 통해 만들어진 초염기서열의 배열은 자식 요소 두개가 머지되어 부모를 만든 것 이외에 서로간 머지가 불가능하다!
-> 이는 DP로 풀때 큰 단서이다.


1 -> 2^n 까지 조합을 구하되 메모이제이션을 응용해라

