---
Date: 2024-02-07
Subject: 정렬, 이제는 피하지 말자
---
## 목차
1. [정렬이란](#1.-정렬이란)
	1-1. [정렬 사용시 이점](#1-1.-정렬 사용시 이점)
	1-2. [자바에서 정렬](#1-2-정렬-자바에서)
2. [비교 클래스, 인터페이스](#2.-비교-클래스,-인터페이스)
	2-1.[Comparator](#2-1.-Comparator)
	2-2.[Comparable](#2-2.-Comparable)
3. [실전은 람다..?](#3.-실전은-람다..?)
## 1. 정렬이란
> ✒️ **정렬**
> 기준이 없는 순서대로 배열되어있는 요소를 어떤 기준에 따라 순서대로 배치하는 것

우리는 이미 정렬의 걔념을 체험적으로 알고있다.

학창시절 반에서 키로 줄을 세운다던가, 성적순으로 등수를 정렬하여 표기하는 것을 볼 수 있다.

기준이 없는 순서대로 배열되어 있는 요소를 기준에 따라 배치함으로써 여러 작업을 수행할 수 있다.

### 1-1. 정렬 사용시 이점
정렬을 사용하면 우리는 데이터가 **특정 기준**으로 순서대로 나열했음을 보증할 수 있다.

데이터를 효율적으로 찾기 위해서는 어떤 기준으로 데이터가 나열되어야한다.

도서관에서 어떤 책을 찾기 위해서 책의 종류 -> 장르 -> 세부적인 순서대로 탐색을 하는것을 생각해보자

만약 모든 책들이 무작위 위치에 있다면 원하는 책 하나를 얻기 위해 모든 도서관을 뒤져야할 수 있다...

### 1-2. 자바에서 정렬
정렬의 종류는 많지만, 이는 알고리즘에서 알아보도록 하자.

이 문서에서는 자바에서 정렬을 어떻게 다루는지, 그리고 내가 원하는 방식대로 정렬하기 위해서는 어떤 방법을 사용해야하는지 확인할 것이다.

자바에서 정렬은 크게 3개의 클래스, 인터페이스안에서 호출할 수 있다.

> sort메소드 호출 가능한 클래스, 인터페이스
> 1. Arrays.sort() -> 제네릭 배열의 자료 sort가능
> 2. Collections.sort() -> List 인터페이스 sort가능!
> 3. List.sort() -> List 인터페이스에서 가능!

우리가 정수 배열을 정렬한다면, 오름차순으로 정렬이 된다.
또한, 문자열 배열을 정렬한다면, 사전순으로 정렬이 된다.
#### 잠깐, 랩퍼 클래스에 기본 정렬 기준은 도대체 어떻게... 만들어진건데?
프로그램을 배워보며, 우리가 너무 당연하게 sort하면 위처럼 정렬이 될 것이라 생각한다.

그런데 이상하다. 어떤 기준으로 정렬 기준을 삼는거지?

정수를 오름차순으로 정렬하려면, 정수 A, 정수 B간 값을 비교할 수 있어야한다.

문자열 역시 마찬가지이다.

사전 순으로 정렬하기 위해선
1. 알파벳 순서대로 나열한다.
2. 알파벳이 동일할 경우 문자열의 길이가 길면 뒤로간다.

두가지 정렬 기준이 존재해야한다..!

[자바 Integer 클래스](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html) 를 살펴보면 compareTo 메서드가 존재한다. 또한, Comparable<>인터페이스의 compareTo를 구현했다 명시한다.

## 2. 비교 클래스, 인터페이스
### 2-1. Comparator
Comparator는 두 객체를 받아 기준에 따라 두 객체의 대소구분을 진행한다.

이 인터페이스는 java.util. 에 위치한 인터페이스인데, 많이 햇갈려하는 부분이 있다.

 Comparator는 Comparable과는 별개다.
	- Comparator를 구현한다고, Comparable한 것은 아니다. Comparator는 비교 연산을 도와주는 역할을 수행하지만 이를 구현하는 클래스가 자체적으로 sort를 수행할수는 없다

#### 사용방법
```java
public class ReverseComparator implements Comparator<Integer>{
	%% 반대로 정렬하기 위해 -1, 0, 1순서 반대로  %%
	@Override
	public int compare(Integer o1, Integer o2){
		if(o1 < o2){
			return 1;
		}
		else if(o1.equals(o2)){
			return 0;
		}
		else{
			return -1;
		}
	}
}
...

public static void main(String[] args){
	Integer[] arr = {1,2,3};

	Arrays.sort(arr, new ReverseComparator());
}
```

오름차순을 구현하기 위해서는 o1이 o2보다 작을경우 -1을 반환해야한다.

ReverseComparator는 내림차순을 구현하고 있으므로 1을 반환했다.

### 2-2. Comparable
Comparable 인터페이스는 Comparator없이 sort를 사용하기 위해 구현해야하는 인터페이스입니다.

Comparator와 차이점은 자기 자신과 파라미터로 받은 객체를 비교한다는 점입니다.

자 여기서 큰 차이점이 나오게됩니다. Comparable 인터페이스에서 구현을 요구하는 메서드는 단 한개 
int compareTo(\<T\> o) 입니다.

이 말은 클래스에서 한가지의 정렬 방법만을 구현할 수 있다는 의미입니다.

따라서, 클래스가 가져야할 기본 정렬 순서를 정의해야할 때 사용할 수 있습니다.

## 3. 실전은 람다..?
우리가 정렬 방법을 제시하는 경우는 많다.

회사에서 많이 사용하는 정렬은 위의 Comparator, Comparable을 구현하는 클래스로 정의해둘 것이다.

하지만 나는 취준생... 이런 정렬방법을 정의하는 것은 주로, 코테 문제에서 많이 사용하고있다.

보통 람다의 메소드를 넣어 처리하는 경우가 많은데, 이는 어떻게된걸까..?

Comparator와 같은 인터페이스는 추상 메서드 하나만 구현하면되는데,이를 **SAM(Single Abstract Method)** 라고 부른다.

또한 이런 SAM은 람다로 처리가 가능하기 때문에, 우리가 코테에서 많이 보는 람다형식의 풀이가 가능한 것이다!

다만, 꼭 람다로 써야할 필요는 없다!